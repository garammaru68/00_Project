1.마우스 레이값
1-1.디렉션 정규화 ( TransformNormal )

2.페이스 리스트

공간분할
원 충돌로 확인 -> 삼각형 충돌

OBB to OBB

마주보고 있는 평면을 노말로 사용

m_tMeshMap
FbxMesh->GetControlPointsCount() - 제어점
		GetControlPoints();

컬러 위치, 노말, 

DxObject.h 수정

LOD + MousePicking + FrustumCulling

ASE 파일은 월드좌표

1.Object 여러개 추가
2.SubMaterial 추가
3.

3DMAX
export - Z-up
tga형식 지원X (BMP로 바꾸기)

모든 페이스를 각각 사용하는 서브 메테리얼을 찾아서 나누고
트라이앵글 리스트(서브 메테리얼 수만큼)를 만들어서
서브 메테리얼당 VB, IB

레이어 하나이상X - 덮어쓰기
하나의 레이어당 pnct
FbxLayerElementMaterial - 
GetMappingMode() 모두의 종류
iSubMtrl = iPoly // iPoly(face)당 텍스쳐 (면 하나가 인덱스)

행렬, 노말, 버텍스 컬러

1.지오메트릭 트랜스폼 - 본(바이패드) 좌표계로 변환(움직일때 마다 원점) - 바이패드(Biped) 공간으로 돌아감
  뼈가 없으면 단위행렬, 
2.로컬 트랜스폼 - 원점에서 월드로 변환
3.애니메이션 트랜스폼 - 시간에 따라 행렬이 달라진다
  월드 좌표 곱하지 않는다.

  행렬에 의한 변환
  normalMatrix = geo의 역행렬 -> 전치
  
  Direct Light 방향
  Point Light 위치
  Spot Light 방향, 위치, 범위

Object Material - 오브젝트 마다 빛을 표현하는 범위가 다르다

eDirect - 배열에 있을 경우
eIndexToDirect  - 인덱스에 데이터가 있을 경우
SDxObject->Update - time을 view(시선)벡터로 넘겨준다

1프레임 4800틱
샘플링 방식		- 곡선 알고리즘이 적용 되어이쓴 파형을 샘플링
네거티브 스케일	- 반대쪽으로 변형하다 좌표 방향이 역전되는 것
				  -1을 곱하면 정상적으로 변함
vColor = m_vLook - 카메라가 바라보는 방향이 라이트 벡터

<Animation>
animationStack = 동작
fFrameTime = 0.033
fSampleTime = fFrameTime * 1.0f(프레임)
Evaluator - 작업 도구
GetNodeGlobalTransform(); - 최종 행렬

<Character>
-논블랜딩-
행렬을 배열로
쉐이더에 넘기고
행렬의 인덱스를 넘긴다

-블래딩-
정점에 인덱스와 가중치 저장